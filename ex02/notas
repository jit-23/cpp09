










if (pend[pend_target_end_idx] > (main[(main_idx - 1) * (cel_size) + ((cel_size/2) - 1)])) // esta certo
        { // o if compara com o head do Ax certo, agora aqui adiciono o pend para o main 
            for (int i = (cel_size/2); i > 0 ; i--) // insert to main  //todo insert in main_str
            {
                vtr_it it = main.begin() + (main_idx ) * (cel_size / 2); 
                std::cout << "pend sending: " << pend[pend_target_end_idx - (cel_size / 2) + i] << std::endl;
                main.insert(it, (pend[pend_target_end_idx - (cel_size / 2) + i]));
                //! after inserting in the main, insert in the _str
                pv(main, BLUE);
            }
            for (int i = 1; i < ((cel_size/2) + 1); i++) // erase in  pend  //todo erase in pend_str
            {
                if (pend.empty())
                    break ;
              //  std::cout<< RED << "pend_erasing: " << *(pend.begin() + pend_idx*(cel_size))<<END << std::endl;
               pend.erase(pend.begin() + pend_idx*(cel_size));
            }
            std::cout <<ORANGE<< "MAIN:"<<END << std::endl;

            
//    pv(main,ORANGE,  cel_size);
//    pv(pend,ORANGE,  cel_size);
//    pv(main_str,ORANGE, cel_size);
        //this->vt = main;
        
        //todo  insert the whole section in it
        
        std::cout << std::endl;
        //todo erase pend[idx]
        
        //todo -> erase the bx in the pend_str and in the pend vector
        //todo -> then send it to main with the same logic to find the ax that correspond to bx;

        
            
            // std::cout << << std::endl;
        }




PmergeMe::PmergeMe(std::string str)
{
    gettimeofday(&start, NULL); // start of analisis
    if (str.empty())
        throw std::runtime_error("empty string");

    for (int i = 0; i < str.size(); i++)
    {
        if (str[i] != ' ' && !isdigit(str[i]))
            throw std::runtime_error("non valid str");
    }
    gettimeofday(&vt_start, NULL);
    fill_vt(str);
    sorted_vt = merge_insertion(raw_vt);
    gettimeofday(&vt_end, NULL);
    fill_lst(str);
   // sorted_lst = merge_insertion(raw_lst);
    std::cout << "\n" << std::endl;
    
    //display_lst_info();
    std::cout << "\n" << std::endl;
    display_vt_info();
}



class PmergeMe
{
    private:
        int vt_size;
        std::vector<int> raw_vt;
        std::vector<int> sorted_vt;
        std::vector<std::pair<int, int> >pair_vt;
        
        timeval start;
        timeval end;

        timeval vt_start;
        timeval vt_end;
        timeval lst_time;

        int lst_size;
        std::list<int> raw_lst;
        std::list<int> sorted_lst;
        std::list<std::pair<int, int> >pair_lst;
    public:
        typedef std::vector<std::pair<int, int> > vector_pair; 
        typedef std::vector<int> vtr; 

        
        typedef std::list<std::pair<int, int> > list_pair; 
        typedef std::list<int> lst; 
        
        PmergeMe(std::string str);
        
        vtr extract_larger_number(vector_pair target);
        lst extract_larger_number(list_pair target);
        
        vtr extract_smaller_number(vector_pair target);
        lst extract_smaller_number(list_pair target);
        
        vtr split(const std::string &str, vtr ret);
        lst split(const std::string &str, lst ret);
        
        void fill_vt( std::string str);
        void fill_lst( std::string str);

        
        void display_vt_info();
        void display_lst_info();
        
        vtr merge_insertion(vtr vt);
        lst merge_insertion(lst vt);
        
        vtr Jacobsthal_insert(vtr vt, int  to_insert);
        
        // for list only//
        lst push_element(PmergeMe::lst list, int index);
        // for list only//
        
        int get_vt_size()const ;
        int get_lst_size()const ;
        
        ~PmergeMe();
};
